
#version 450

#include "../includes/structs.glsl"

layout(set = 0, binding = 1) uniform AnimationInfoUniform {
    AnimationInfo animation_info;
};

layout(set = 0, binding = 2) writeonly buffer LocalTransforms {
    Similarity local_transforms[];
};

layout(set = 0, binding = 3) readonly buffer AnimationStates {
    AnimationState animation_states[];
};

layout(set = 1, binding = 0) readonly buffer TranslationInputs {
    float translation_inputs[];
};

layout(set = 1, binding = 1) readonly buffer TranslationOutputs {
    vec3 translation_outputs[];
};

layout(set = 1, binding = 2) readonly buffer TranslationChannels {
    Channel translation_channels[];
};

#define CHANNEL_INPUTS translation_inputs
#define CHANNEL_OUTPUTS translation_outputs
#define SAMPLE_TYPE vec3
#include "sampling.glsl"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main() {
    uint index = gl_GlobalInvocationID.x;

    uint channels_per_animation = translation_channels.length();

    uint animation_index = index / channels_per_animation;
    uint channel_index = index % channels_per_animation;
    uint node_index = animation_index * animation_info.num_nodes;

    if (animation_index >= animation_info.num_instances) {
        return;
    }

    float time = animation_states[animation_index].time;

    Channel channel = translation_channels[channel_index];
    bool invalid = false;
    vec3 translation = sample_cubic_spline(time, channel, invalid);
    if (!invalid) {
        local_transforms[node_index + channel.node_index].translation = translation;
    }
}
