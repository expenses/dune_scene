
#version 450

#include "../includes/structs.glsl"
#include "../includes/matrices.glsl"
#include "../includes/rotor.glsl"

mat4 similarity_to_mat4(Similarity sim) {
    mat4 scale_matrix = scale_matrix(sim.scale);
    mat4 translation_matrix = translation_matrix(sim.translation);
    mat4 rotation_matrix = mat4(rotor_to_matrix(sim.rotation));

    return translation_matrix * rotation_matrix * scale_matrix;
}

layout(set = 0, binding = 0) writeonly buffer JointTransforms {
    mat4 joint_transforms[];
};

layout(set = 0, binding = 1) uniform AnimationInfoUniform {
    AnimationInfo animation_info;
};

layout(set = 0, binding = 4) readonly buffer GlobalTransforms {
    Similarity global_transforms[];
};

layout(set = 0, binding = 6) readonly buffer JointIndicesToNodeIndices {
    uint joint_indices_to_node_indices[];
};

layout(set = 0, binding = 7) readonly buffer InverseBindMatrices {
    mat4 inverse_bind_matrices[];
};

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main() {
    uint global_joint_index = gl_GlobalInvocationID.x;

    uint instance_index = global_joint_index / animation_info.num_joints;

    if (instance_index >= animation_info.num_instances) {
        return;
    }

    uint global_node_offset = instance_index * animation_info.num_nodes;
    uint local_joint_index = global_joint_index % animation_info.num_joints;
    uint global_node_index = global_node_offset + joint_indices_to_node_indices[local_joint_index];

    mat4 inverse_bind_matrix = inverse_bind_matrices[local_joint_index];
    mat4 matrix_global_transform = similarity_to_mat4(global_transforms[global_node_index]);

    joint_transforms[global_joint_index] = matrix_global_transform * inverse_bind_matrix;
}
